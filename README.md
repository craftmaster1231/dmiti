# Дискретные задачи многокритериальной оптимизации.

## Несколько понятий.

### Пусть есть множество каких-то объектов. У каждого объекта есть какие-то параметры. Надо выбрать из этого множества лучшие объекты по парметрам. 
### Для каждого параметра надо выбрать, лучший "воображаемый" объект должен минимизировать его, или максимизировать. 
### Множество Парето - такое подмножество объектов, для которых нельзя во всем множестве выбрать объект, который будет лучше по всем параметрам.
    
    На простых примерах: 
    1. Большое и кислое яблоко | маленькое, но сладкое яюлоко.
    В случае, когда мы хотим и сладкое и большое яблоко, - это множество Парето.
    2. Дорогой, но крепкий телефон | дешевый, но хрупкий телефон. 
    В случае, когда наша цель минимизировать затраты и максимизироать надежность, - это множество Парето.
    
## Первая программа будет обрабатывать несколько точек и находить среди них множество Парето. 

### *Каков алгоритм?*

У каждой точки будет свой идентификатор, просто номер.

По определению множества Парето,
мне надо проверить для каждой точки,
есть ли точки, которые лучше нее
по **всем** параметрам. Проверять 
буду по порядку номеров.

*Буду называть такие точки просто
теми, которые лучше,а те, что
лучше не по всем
параметрам - несравнимыми.*

*Те, что хуже по всем параметрам
буду называть худшими 
для другой точки*

Так и сделаю. Для каждой точки проверю все остальные.
Если для какой-то точки нашлась точка лучше,
то она не входит в множество, а если она
несравнима со всеми, и не хуже никакой,
то она входит в множество Парето. 

Таким образом, у меня останутся только те
точки, которые входят в множество Парето.

## Работа первой программы
---


Enter number of parameters for each object

3

Enter number of objects

5

Enter parameters of object 1

1 2 3

Enter parameters of object 2

3 2 1

Enter parameters of object 3

1 1 1

Enter parameters of object 4

2 2 5

Enter parameters of object 5

5 2 2

Pareto multitude:

2 2 5 

5 2 2 

---

## Что дальше?

### После того, как было положено начало в виде рабочей программы, появилось несколько идей для оптимизации

#### 1. Структура данных list была выбрана не просто так. В будущем будет оптимально по времени добавлять новые объекты к множеству.

#### 2. Кажется, что если отсортировать список по модулю векторов, которые образуют объекты, то алгоритм будет быстрее находить неподходящие множеству Парето элементы, так как если если модуль одного вектора больше, чем вектор второго, то второй точно не может быть лучше.
